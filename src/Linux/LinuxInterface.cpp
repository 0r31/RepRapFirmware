/*
 * LinuxInterface.cpp
 *
 *  Created on: 29 Mar 2019
 *      Author: Christian
 */


#include "LinuxInterface.h"
#include "DataTransfer.h"
#include "MessageFormats.h"

#include "RepRapFirmware.h"
#include "GCodes/GCodes.h"
#include "GCodes/GCodeBuffer/BinaryGCodeBuffer.h"
#include "Platform.h"
#include "PrintMonitor.h"
#include "RepRap.h"

#if HAS_LINUX_INTERFACE

LinuxInterface::LinuxInterface() : transfer(new DataTransfer()), gcodeReply(new OutputStack())
{
}

void LinuxInterface::Init()
{
	transfer->Init();
}

GCodeBuffer *LinuxInterface::InitGCodeBuffer()
{
	spiGCodeBuffer = new BinaryGCodeBuffer(CodeChannel::SPI, MessageType::SpiMessage, true);
	return spiGCodeBuffer;
}

void LinuxInterface::Spin()
{
	if (transfer->IsReady())
	{
		for (;;)
		{
			const PacketHeader *packet = transfer->ReadPacket();
			if (packet == nullptr)
			{
				break;
			}

			if (packet->request >= (uint16_t)LinuxRequest::InvalidRequest)
			{
				INTERNAL_ERROR;
				return;
			}
			const LinuxRequest request = (LinuxRequest)packet->request;

			switch (request)
			{
			// Request the state of the G-Code buffers
			case LinuxRequest::RequestState:
			{
				uint32_t busyBuffers = 0;
				if (!spiGCodeBuffer->IsCompletelyIdle()) { busyBuffers |= (1 >> (uint16_t)CodeChannel::SPI); }
				if (!transfer->WriteState(busyBuffers))
				{
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Perform an emergency stop
			case LinuxRequest::EmergencyStop:
				reprap.EmergencyStop();
				break;

			// Reset the controller
			case LinuxRequest::Reset:
				reprap.GetPlatform().SoftwareReset((uint16_t)SoftwareResetReason::user);
				break;

			// Perform a G/M/T-code
			case LinuxRequest::Code:
			{
				size_t dataLength = packet->length;
				const char *data = transfer->ReadData(dataLength);
				(void)spiGCodeBuffer->Put(data, dataLength);
				break;
			}

			// Get the object model of a specific module
			case LinuxRequest::GetObjectModel:
			{
				OutputBuffer *buffer;
				if (OutputBuffer::Allocate(buffer) && reprap.ReportAsJson(buffer, "", ObjectModel::flagsNone))
				{
					if (transfer->WriteObjectModel(buffer))
					{
						// The whole buffer chain has already been freed
						buffer = nullptr;
					}
					else
					{
						// Failed to write the whole object model, try again later
						transfer->ResendPacket(packet);
						OutputBuffer::ReleaseAll(buffer);
					}
				}
				else
				{
					// No output buffer could be allocated, this means RRF is really short on memory
					transfer->ResendPacket(packet);
					OutputBuffer::ReleaseAll(buffer);
				}
				break;
			}

			// Set the object model value
			case LinuxRequest::SetObjectModel:
			{
				size_t dataLength = packet->length;
				const char *data = transfer->ReadData(dataLength);
				// TODO implement this
				(void)data;
				break;
			}

			// Print has been started, set file print info
			case LinuxRequest::PrintStarted:
			{
				String<MaxFilenameLength> filename;
				StringRef filenameRef = filename.GetRef();
				transfer->ReadPrintStartedInfo(packet->length, filenameRef, fileInfo);
				reprap.GetPrintMonitor().SetPrintingFileInfo(filename.c_str(), fileInfo);
				reprap.GetGCodes().StartPrinting(true);
				break;
			}

			// Print has been stopped
			case LinuxRequest::PrintStopped:
			{
				StopPrintReason actualReason = (StopPrintReason)transfer->ReadPrintStoppedInfo();
				reprap.GetGCodes().StopPrint(actualReason);
				break;
			}

			// Macro file has been finished
			case LinuxRequest::MacroCompleted:
			{
				CodeChannel channel;
				bool error;
				transfer->ReadMacroCompleteInfo(channel, error);

				spiGCodeBuffer->FileEnded();
				break;
			}

			// Retrieve full heightmap as generated by G29
			case LinuxRequest::GetHeightMap:
			{
				if (!transfer->WriteHeightMap())
				{
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Lock movement and wait for standstill
			case LinuxRequest::LockMovementAndWaitForStandstill:
#if 0
				// TODO implement this: 1) check resource
				// TODO possibly request resend as long as this does not return true, would guarantee it eventually works
				reprap.GetGCodes().LockMovementAndWaitForStandstill(*spiGCodeBuffer);
#endif
				break;

			// Unlock everything
			case LinuxRequest::Unlock:
#if 0
				// TODO implement this
				reprap.GetGCodes().UnlockAll(*spiGCodeBuffer);
#endif
				break;

			// Invalid request
			default:
			{
				INTERNAL_ERROR;
				break;
			}
			}
		}

		// Deal with macro file requests
		bool reportMissing;
		const char *requestedMacroFile = spiGCodeBuffer->GetRequestedMacroFile(reportMissing);
		if (requestedMacroFile != nullptr)
		{
			if (transfer->WriteMacroRequest(requestedMacroFile, reportMissing))
			{
				spiGCodeBuffer->SetRequestedMacroFile(nullptr, false);
			}
		}

		// Deal with code replies
		if (!gcodeReply->IsEmpty())
		{
			MessageType type = gcodeReply->GetFirstItemType();
			OutputBuffer *buffer = gcodeReply->GetFirstItem();
			buffer = transfer->WriteCodeResponse(CodeChannel::SPI, type, buffer, /*(type & MessageType::LastMessageFlag) != 0*/ true);
			gcodeReply->SetFirstItem(buffer);
		}
	}
}

bool LinuxInterface::RequestMacroFile(GCodeBuffer& gb, const char *filename, bool reportMissing)
{
	if (&gb == spiGCodeBuffer)
	{
		spiGCodeBuffer->SetRequestedMacroFile(filename, reportMissing);
		return true;
	}
	return false;
}

void LinuxInterface::HandleGCodeReply(MessageType mt, const char *reply)
{
	OutputBuffer *buffer = gcodeReply->GetLastItem();
	if (buffer == nullptr || buffer->IsReferenced() || gcodeReply->GetLastItemType() != mt)
	{
		if (!OutputBuffer::Allocate(buffer))
		{
			// No more space available, stop here
			return;
		}
		gcodeReply->Push(buffer, mt);
	}

	buffer->cat(reply);
}

void LinuxInterface::HandleGCodeReply(MessageType mt, OutputBuffer *buffer)
{
	gcodeReply->Push(buffer, mt);
}

#endif
