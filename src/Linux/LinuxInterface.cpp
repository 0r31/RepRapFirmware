/*
 * LinuxInterface.cpp
 *
 *  Created on: 29 Mar 2019
 *      Author: Christian
 */


#include "LinuxInterface.h"
#include "DataTransfer.h"
#include "MessageFormats.h"

#include "GCodes/GCodeBuffer/GCodeBuffer.h"
#include "GCodes/GCodes.h"
#include "Platform.h"
#include "PrintMonitor.h"
#include "RepRap.h"
#include "RepRapFirmware.h"

#if HAS_LINUX_INTERFACE

LinuxInterface::LinuxInterface() : transfer(new DataTransfer()), gcodeReply(new OutputStack())
{
}

void LinuxInterface::Init()
{
	transfer->Init();

	// RepRap does not wait for config.g because DCS may not be running.
	// Request it as the first action from the Linux controller
	transfer->WriteMacroRequest(CodeChannel::daemon, CONFIG_FILE, true);
}

void LinuxInterface::Spin()
{
	if (transfer->IsReady())
	{
		for (;;)
		{
			const PacketHeader *packet = transfer->ReadPacket();
			if (packet == nullptr)
			{
				break;
			}

			if (packet->request >= (uint16_t)LinuxRequest::InvalidRequest)
			{
				INTERNAL_ERROR;
				return;
			}
			const LinuxRequest request = (LinuxRequest)packet->request;

			switch (request)
			{
			// Request the state of the G-Code buffers
			case LinuxRequest::GetState:
			{
				uint32_t busyBuffers = 0;
				for (size_t i = 0; i < NumGCodeBuffers; i++)
				{
					if (!reprap.GetGCodes().GetGCodeBuffer(i)->IsCompletelyIdle())
					{
						busyBuffers |= (1 >> i);
					}
				}

				if (!transfer->WriteState(busyBuffers))
				{
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Perform an emergency stop
			case LinuxRequest::EmergencyStop:
				reprap.EmergencyStop();
				break;

			// Reset the controller
			case LinuxRequest::Reset:
				reprap.GetPlatform().SoftwareReset((uint16_t)SoftwareResetReason::user);
				break;

			// Perform a G/M/T-code
			case LinuxRequest::Code:
			{
				size_t dataLength = packet->length;
				const char *data = transfer->ReadData(dataLength);
				const CodeReplyHeader *header = reinterpret_cast<const CodeReplyHeader*>(data);

				GCodeBuffer *buffer = reprap.GetGCodes().GetGCodeBuffer((size_t)header->channel);
				if (buffer->IsCompletelyIdle())
				{
					buffer->Put(data, dataLength, true);
				}
				else
				{
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Get the object model of a specific module
			case LinuxRequest::GetObjectModel:
			{
				OutputBuffer *buffer;
				if (OutputBuffer::Allocate(buffer) && reprap.ReportAsJson(buffer, "", ObjectModel::flagsNone))
				{
					if (transfer->WriteObjectModel(buffer))
					{
						// The whole buffer chain has already been freed
						buffer = nullptr;
					}
					else
					{
						// Failed to write the whole object model, try again later
						transfer->ResendPacket(packet);
						OutputBuffer::ReleaseAll(buffer);
					}
				}
				else
				{
					// No output buffer could be allocated, this means RRF is really short on memory
					transfer->ResendPacket(packet);
					OutputBuffer::ReleaseAll(buffer);
				}
				break;
			}

			// Set the object model value
			case LinuxRequest::SetObjectModel:
			{
				size_t dataLength = packet->length;
				const char *data = transfer->ReadData(dataLength);
				// TODO implement this
				(void)data;
				break;
			}

			// Print has been started, set file print info
			case LinuxRequest::PrintStarted:
			{
				String<MaxFilenameLength> filename;
				StringRef filenameRef = filename.GetRef();
				transfer->ReadPrintStartedInfo(packet->length, filenameRef, fileInfo);
				reprap.GetPrintMonitor().SetPrintingFileInfo(filename.c_str(), fileInfo);
				reprap.GetGCodes().StartPrinting(true);
				break;
			}

			// Print has been stopped
			case LinuxRequest::PrintStopped:
			{
				const PrintStoppedReason reason = transfer->ReadPrintStoppedInfo();
				if (reason == PrintStoppedReason::normalCompletion)
				{
					// Just mark the print file as finished
					GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer((size_t)CodeChannel::file);
					gb->SetPrintFinished();
				}
				else
				{
					// Stop the print with the given reason
					reprap.GetGCodes().StopPrint((StopPrintReason)reason);
				}
				break;
			}

			// Macro file has been finished
			case LinuxRequest::MacroCompleted:
			{
				CodeChannel channel;
				bool error;
				transfer->ReadMacroCompleteInfo(channel, error);

				GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer((size_t)channel);
				gb->MachineState().SetFileFinished();
				break;
			}

			// Retrieve full heightmap as generated by G29
			case LinuxRequest::GetHeightMap:
			{
				if (!transfer->WriteHeightMap())
				{
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Lock movement and wait for standstill
			case LinuxRequest::LockMovementAndWaitForStandstill:
#if 0
				// TODO implement this: 1) check resource
				// TODO possibly request resend as long as this does not return true, would guarantee it eventually works
				reprap.GetGCodes().LockMovementAndWaitForStandstill(*spiGCodeBuffer);
#endif
				break;

			// Unlock everything
			case LinuxRequest::Unlock:
#if 0
				// TODO implement this
				reprap.GetGCodes().UnlockAll(*spiGCodeBuffer);
#endif
				break;

			// Invalid request
			default:
			{
				INTERNAL_ERROR;
				break;
			}
			}
		}

		// Deal with macro file requests
		bool reportMissing;
		for (size_t i = 0; i < NumGCodeBuffers; i++)
		{
			GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer(i);
			const CodeChannel channel = (CodeChannel)i;

			// Handle macro start requests
			const char *requestedMacroFile = gb->GetRequestedMacroFile(reportMissing);
			if (requestedMacroFile != nullptr)
			{
				if (transfer->WriteMacroRequest(channel, requestedMacroFile, reportMissing))
				{
					gb->RequestMacroFile(nullptr, false);
				}
			}
			// Handle macro cancellation requests
			else if (gb->IsMacroCancellationRequested())
			{
				if (transfer->WriteAbortFileRequest(channel))
				{
					gb->AcknowledgeCancellation();
				}
			}
		}

		// Deal with code replies
		if (!gcodeReply->IsEmpty())
		{
			MessageType type = gcodeReply->GetFirstItemType();
			OutputBuffer *buffer = gcodeReply->GetFirstItem();
			// TODO make function to convert MessageType to CodeChannel
			buffer = transfer->WriteCodeResponse(CodeChannel::spi, type, buffer, /*(type & MessageType::LastMessageFlag) != 0*/ true);
			gcodeReply->SetFirstItem(buffer);
		}
	}
}

void LinuxInterface::PrintPaused(FilePosition position)
{
	// TODO enqueue packet
}

void LinuxInterface::HandleGCodeReply(MessageType mt, const char *reply)
{
	OutputBuffer *buffer = gcodeReply->GetLastItem();
	if (buffer == nullptr || buffer->IsReferenced() || gcodeReply->GetLastItemType() != mt)
	{
		if (!OutputBuffer::Allocate(buffer))
		{
			// No more space available, stop here
			return;
		}
		gcodeReply->Push(buffer, mt);
	}

	buffer->cat(reply);
}

void LinuxInterface::HandleGCodeReply(MessageType mt, OutputBuffer *buffer)
{
	gcodeReply->Push(buffer, mt);
}

#endif
